import { useState } from 'react';
import { supabase } from '../lib/supabase';
import { N8N_RAILWAY_CONFIG } from '../lib/n8nConfig';
import toast from 'react-hot-toast';

interface N8NRequest {
  type: 'resume' | 'cover-letter';
  user_id: string;
  user_email: string;
  request_id: string;
  timestamp: string;
  data: {
    company_name: string;
    job_title: string;
    job_description: string;
    selected_job_id?: string;
    // Cover letter specific
    hiring_manager?: string;
    tone?: string;
    personal_experience?: string;
    why_company?: string;
  };
}

export function useAIGenerationService() {
  const [loading, setLoading] = useState(false);
  const [progress, setProgress] = useState(0);
  const [timeRemaining, setTimeRemaining] = useState(0);
  const [generatedContent, setGeneratedContent] = useState('');
  const [currentRequestId, setCurrentRequestId] = useState<string | null>(null);

  const generateRequestId = () => {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  };

  const sendToN8N = async (
    type: 'resume' | 'cover-letter',
    data: any,
    webhookUrl: string
  ): Promise<string> => {
    const { data: { user } } = await supabase.auth.getUser();
    if (!user) throw new Error('User not authenticated');

    const requestId = generateRequestId();
    
    const payload: N8NRequest = {
      type,
      user_id: user.id,
      user_email: user.email || '',
      request_id: requestId,
      timestamp: new Date().toISOString(),
      data
    };

    console.log('ðŸš€ Sending to N8N Railway:', payload);

    const response = await fetch(webhookUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'User-Agent': 'JobTracker-AI/1.0',
        'X-Request-Source': 'jobtracker-ai',
        'X-Railway-Domain': 'tracker.satvik.live'
      },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      const errorText = await response.text().catch(() => 'Unknown error');
      throw new Error(`N8N Railway webhook failed: ${response.status} ${response.statusText} - ${errorText}`);
    }

    return requestId;
  };

  const callGeminiAPI = async (
    prompt: string,
    apiKey: string
  ): Promise<string> => {
    const url = `https://generativelanguage.googleapis.com/v1/models/gemini-1.5-flash:generateContent?key=${apiKey}`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              {
                text: prompt
              }
            ]
          }
        ],
        generationConfig: {
          temperature: 0.7,
          topK: 40,
          topP: 0.95,
          maxOutputTokens: 8192
        }
      })
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
      throw new Error(`Gemini API error: ${errorData.error?.message || response.statusText}`);
    }

    const data = await response.json();
    
    // Extract the generated text from the response
    const generatedText = data.candidates?.[0]?.content?.parts?.[0]?.text || '';
    
    if (!generatedText) {
      throw new Error('No content generated by Gemini API');
    }
    
    return generatedText;
  };

  const createResumePrompt = (formData: any): string => {
    return `You are an expert resume writer and ATS (Applicant Tracking System) optimizer. Your task is to provide tailored resume suggestions based on the provided job description. Focus on extracting key skills, keywords, and responsibilities, and suggest how the user can incorporate them into their resume's professional summary, experience section (with action verbs and quantifiable achievements), and technical skills section. The output should be in plain text, clearly structured with headings and bullet points.

Job Title: ${formData.job_title}
Company Name: ${formData.company_name}
Job Description: ${formData.job_description}

Provide suggestions for:
1. **Keyword Optimization**: List 5-10 critical keywords from the job description.
2. **Professional Summary**: Suggest a 2-3 sentence summary tailored to this role.
3. **Experience Section**: Provide 3-5 examples of quantifiable achievements using strong action verbs relevant to the job.
4. **Technical Skills**: List 5-8 technical skills directly mentioned or implied.
5. **ATS Tips**: Give 3-5 general ATS optimization tips.`;
  };

  const createCoverLetterPrompt = (formData: any): string => {
    return `You are a professional cover letter writer. Draft a compelling cover letter for the position of ${formData.job_title} at ${formData.company_name}. The letter should be written in a ${formData.tone} tone. Incorporate the provided job description, the user's personal experience, and their reasons for interest in the company. Address the hiring manager as ${formData.hiring_manager || 'Hiring Manager'}. The output should be a complete, well-structured cover letter in plain text.

Job Title: ${formData.job_title}
Company Name: ${formData.company_name}
Hiring Manager: ${formData.hiring_manager || 'Hiring Manager'}
Tone: ${formData.tone}
Job Description: ${formData.job_description}
My Relevant Experience: ${formData.personal_experience || ''}
Why I'm Interested in This Company: ${formData.why_company || ''}

Ensure the letter includes:
1. A strong opening paragraph expressing enthusiasm.
2. A body paragraph connecting personal experience and skills to job requirements.
3. A paragraph explaining genuine interest in the company.
4. A professional closing.`;
  };

  const startProgressTimer = (duration: number = 240) => {
    setTimeRemaining(duration);
    setProgress(0);
    
    const interval = setInterval(() => {
      setTimeRemaining(prev => {
        if (prev <= 1) {
          clearInterval(interval);
          return 0;
        }
        return prev - 1;
      });
      
      setProgress(prev => {
        const newProgress = ((duration - timeRemaining + 1) / duration) * 100;
        return Math.min(newProgress, 95); // Cap at 95% until we get response
      });
    }, 1000);

    return interval;
  };

  const generateContent = async (
    type: 'resume' | 'cover-letter',
    formData: any
  ) => {
    try {
      setLoading(true);
      setGeneratedContent('');
      
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('User not authenticated');

      // Get user settings to determine AI provider
      const { data: settings, error: settingsError } = await supabase
        .from('user_settings')
        .select('ai_provider, openai_api_key, gemini_api_key')
        .eq('user_id', user.id)
        .single();

      if (settingsError && settingsError.code !== 'PGRST116') {
        console.warn('Error fetching user settings:', settingsError);
      }

      const aiProvider = settings?.ai_provider || 'n8n';
      
      // Start progress timer - shorter for direct API calls
      const duration = aiProvider === 'n8n' ? 65 : 20;
      const timer = startProgressTimer(duration);
      
      let content = '';
      
      // Use the appropriate AI provider
      if (aiProvider === 'gemini' && settings?.gemini_api_key) {
        try {
          // Create prompt based on content type
          const prompt = type === 'resume' 
            ? createResumePrompt(formData)
            : createCoverLetterPrompt(formData);
          
          // Call Gemini API directly
          content = await callGeminiAPI(prompt, settings.gemini_api_key);
          
          // Update progress to 100%
          setTimeout(() => {
            clearInterval(timer);
            setProgress(100);
            setTimeRemaining(0);
            setGeneratedContent(content);
            setLoading(false);
          }, 1000);
          
          // Update AI Resume table if it's a resume generation
          if (type === 'resume' && formData.selected_job_id) {
            await updateAiResumeTable(formData.selected_job_id, content, user.id);
          }
          
          toast.success(`${type === 'resume' ? 'Resume suggestions' : 'Cover letter'} generated successfully!`);
        } catch (error: any) {
          clearInterval(timer);
          console.error('Gemini API error:', error);
          toast.error(`Gemini API error: ${error.message}`);
          throw error;
        }
      } else if (aiProvider === 'openai' && settings?.openai_api_key) {
        // OpenAI implementation would go here
        toast.error('OpenAI integration not implemented yet. Please use Gemini or N8N.');
        clearInterval(timer);
        throw new Error('OpenAI integration not implemented');
      } else {
        // Default to N8N workflow
        try {
          // Use the Railway webhook URL
          const webhookUrl = N8N_RAILWAY_CONFIG.WEBHOOK_URL;
          
          // Send request to N8N
          const requestId = await sendToN8N(type, formData, webhookUrl);
          setCurrentRequestId(requestId);
          
          // Poll for response
          const pollForResponse = async () => {
            const maxAttempts = 240; // 70 seconds max wait
            let attempts = 0;
            
            const poll = async (): Promise<void> => {
              if (attempts >= maxAttempts) {
                clearInterval(timer);
                setLoading(false);
                setProgress(100);
                throw new Error('Request timed out. Please try again.');
              }
              
              attempts++;
              
              // Check if we received a response
              const response = await checkForResponse(requestId);
              
              if (response) {
                clearInterval(timer);
                setProgress(100);
                setTimeRemaining(0);
                
                if (response.status === 'success' && response.content) {
                  setGeneratedContent(response.content);
                  
                  // Ensure loading state is reset
                  setTimeout(() => {
                    setLoading(false);
                  }, 1000);
                  
                  // Update AI Resume table if it's a resume generation
                  if (type === 'resume' && formData.selected_job_id) {
                    await updateAiResumeTable(formData.selected_job_id, response.content, user.id);
                  }
                  
                  toast.success(`${type === 'resume' ? 'Resume suggestions' : 'Cover letter'} generated successfully!`);
                } else {
                  throw new Error(response.error_message || 'Generation failed');
                }
                
                return;
              }
              
              // Continue polling
              setTimeout(poll, 1000);
            };
            
            poll();
          };
          
          pollForResponse();
        } catch (error: any) {
          clearInterval(timer);
          console.error('N8N error:', error);
          toast.error(`N8N error: ${error.message}`);
          throw error;
        }
      }
    } catch (error: any) {
      console.error('Error generating content:', error);
      setLoading(false);
      setProgress(0);
      setTimeRemaining(0);
      toast.error(error.message || 'Failed to generate content');
      throw error;
    }
  };

  const updateAiResumeTable = async (jobId: string, content: string, userId: string) => {
    try {
      // Extract sample data for demonstration - in real implementation, this would come from AI analysis
      const sampleKeywords = [
        'JavaScript', 'TypeScript', 'React', 'Node.js', 'Python', 'SQL', 'AWS', 'Docker', 'Git', 'Agile'
      ];
      
      const sampleSkills = [
        'Problem Solving', 'Communication', 'Leadership', 'Teamwork', 'Project Management', 'Analytical Thinking'
      ];

      const { error } = await supabase
        .from('ai_resume')
        .update({
          user_id: userId,
          resume_content: content,
          keywords_extracted: sampleKeywords,
          skills_required: sampleSkills,
          ats_score: Math.floor(Math.random() * 30) + 70, // Random score between 70-100
          suggestions_count: Math.floor(Math.random() * 10) + 5, // Random count between 5-15
          is_processed: true,
          processing_status: 'completed',
          generated_at: new Date().toISOString(),
          updated_at: new Date().toISOString()
        })
        .eq('id', jobId);

      if (error) {
        console.error('Error updating AI resume table:', error);
      } else {
        console.log('âœ… AI Resume table updated successfully');
      }
    } catch (error) {
      console.error('Error updating AI resume table:', error);
    }
  };

  const checkForResponse = async (requestId: string) => {
    try {
      // Check our database for the response
      const { data, error } = await supabase
        .from('ai_generations')
        .select('*')
        .eq('request_id', requestId)
        .single();

      if (error && error.code !== 'PGRST116') {
        console.error('Error checking for response:', error);
        return null;
      }

      if (data && data.content) {
        return {
          request_id: requestId,
          type: data.type,
          status: 'success',
          content: data.content
        };
      }

      return null;
    } catch (error) {
      console.error('Error checking for response:', error);
      return null;
    }
  };

  const resetState = () => {
    setLoading(false);
    setProgress(0);
    setTimeRemaining(0);
    setGeneratedContent('');
    setCurrentRequestId(null);
  };

  return {
    loading,
    progress,
    timeRemaining,
    generatedContent,
    currentRequestId,
    generateContent,
    resetState,
    setGeneratedContent
  };
}